

# This file was *autogenerated* from the file db1.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2)
from sage.all import *

def cmp_elements_key(x):
    """
    A helper function to compare elements which may be integers or strings.

    EXAMPLES::

        sage: from sage.matroids.utilities import cmp_elements_key
        sage: l = ['a', 'b', 1, 3, 2, 10, 111, 100, 'c', 'aa']
        sage: sorted(l, key=cmp_elements_key)
        [1, 2, 3, 10, 100, 111, 'a', 'aa', 'b', 'c']
    """
    return (isinstance(x, str), x)

def characteristic_polynomial(M, la=None):
    R = ZZ['l']
    w = whitney_numbers(M)
    w.reverse()
    chi = R(w)
    if la is not None:
        return chi(la)
    return chi

def whitney_numbers(M):
    abs_w = [_sage_const_0 ] * (M.rank() + _sage_const_1 )
    for S in no_broken_circuits_sets_iterator(M):
        abs_w[len(S)] += _sage_const_1 
    return [ZZ((-_sage_const_1 )**i * val) for i, val in enumerate(abs_w) if val != _sage_const_0 ]

def no_broken_circuits_sets_iterator(M, ordering=None):
    if M.loops():
        return
    if ordering is None:
        rev_order = sorted(M.groundset(), key=cmp_elements_key, reverse=True)
    else:
        if frozenset(ordering) != M.groundset():
            raise ValueError("not an ordering of the groundset")
        rev_order = list(reversed(ordering))
    
    Tmax = len(rev_order)
    reverse_dict = {value: key for key, value in enumerate(rev_order)}
    yield frozenset()
    next_level = [[val] for val in rev_order]
    level = -_sage_const_1 
    
    while next_level:
        cur_level = next_level
        next_level = []
        level += _sage_const_1 
        for H in cur_level:
            tp = reverse_dict[H[level]] + _sage_const_1 
            is_indep = True
            Ht = [None] * (Tmax - tp)
            for i in range(tp, Tmax):
                temp = H + [rev_order[i]]
                if not M._is_independent(frozenset(temp)):
                    is_indep = False
                    break
                Ht[i - tp] = temp
            if is_indep:
                yield frozenset(H)
                next_level.extend(Ht)
                
R = PolynomialRing(QQ, 't')
t = R.gen(0)

def is_paving(M):
    n = M.size()
    r = M.rank()
    return (len(M.independent_r_sets(r-_sage_const_1 )) == binomial(n, r-_sage_const_1 ))

def q_kl(k, h):
    return kazhdan_lusztig_inverse_uniform(k, h+_sage_const_1 ) - kazhdan_lusztig_inverse_uniform(k-_sage_const_1 , h)

def kl_inverse_fast(M):
    if M.loops(): return R(_sage_const_0 )
    k, n = M.rank(), M.size()
    if k == n or k == _sage_const_0 : return R(_sage_const_1 )
    if not M.is_connected():
        ans = R(_sage_const_1 )
        CC = M.components()
        for N in CC:
            res = M.delete(M.groundset() - N)
            ans = ans * kl_inverse_fast(res)
        return ans

    if is_paving(M):
        return kl_inverse_paving(M)
    if is_paving(M.dual()):
        return kl_inverse_copaving(M)
    """
    if n <= 8 and M.is_connected():
        for i in range(len(mat[n][k])):
            if mat[n][k][i].is_isomorphic(M):
                return ikl[n][k][i]
    """
    LF = M.lattice_of_flats()
    ans = R(_sage_const_0 )
    for F in LF:
        if len(F) != n:
            Res = M.delete(M.groundset() - F)
            Con = M.contract(F)
            chi = characteristic_polynomial(Con)(_sage_const_1 /t) * t**(Con.rank())
            PPP = kl_inverse_fast(Res)(t) * (-_sage_const_1 )**(Res.rank())
            ans = ans + chi * PPP
    assert (t**k * ans(_sage_const_1 /t)).numerator() == -ans(t)
    ans = ans.numerator() * (-_sage_const_1 )**(k+_sage_const_1 )
    return ans.truncate((k+_sage_const_1 )//_sage_const_2 )

def kazhdan_lusztig_inverse_uniform(k, n):
    if k == n:
        return R(_sage_const_1 )
    d = k
    m = n - d
    ans = _sage_const_0 
    for j in range((d-_sage_const_1 )//_sage_const_2  + _sage_const_1 ):
        ans = ans + m * (d-_sage_const_2 *j)/((m+j) * (m+d-j)) * binomial(d, j) * t**j
    return ans * binomial(m+d, d)

def kl_inverse_paving(M):
    assert is_paving(M)
    n = M.size()
    k = M.rank()
    ans = kazhdan_lusztig_inverse_uniform(k, n)
    for H in M.hyperplanes():
        h = len(H)
        if h >= k:
            ans = ans - q_kl(k, h)
    return ans

def kl_inverse_copaving(M):
    assert is_paving(M.dual())
    n = M.size()
    k = M.rank()
    ans = kazhdan_lusztig_inverse_uniform(k, n)
    for H in M.dual().hyperplanes():
        h = len(H)
        if h >= n-k:
            ans = ans - kli_vtilde_dual(n-k, h, n) + kazhdan_lusztig_inverse_uniform(h-n+k+_sage_const_1 , h) * kazhdan_lusztig_inverse_uniform(n-h-_sage_const_1 , n-h)
    return ans

def kli_vtilde_dual(k, h, n):
    return helper1(n-k, h, n)

def helper1(k, h, n):
    c = n - h
    ans1 = kazhdan_lusztig_inverse_uniform(k, n)
    ans2 = helper2(c, k, n)
    ans3 = kazhdan_lusztig_inverse_uniform(k-c+_sage_const_1 , h) * kazhdan_lusztig_inverse_uniform(c-_sage_const_1 , c)
    return ans1 - ans2 + ans3

def helper2(c, k, n):
    h = n - c
    ans = _sage_const_0 
    for j in range(k-c+_sage_const_1 ):
        ans = ans + binomial(n-c, j) * (-_sage_const_1 )**(c-_sage_const_1 +j) * kazhdan_lusztig_inverse_uniform(c-_sage_const_1 , c) * t**(k-c-j+_sage_const_1 ) * chuly(k-c-j+_sage_const_1 , n-c-j)(_sage_const_1 /t)
    for i in range(c-_sage_const_1 ):
        for j in range(k-i):
            ans = ans + binomial(c, i) * binomial(n-c, j) * (-_sage_const_1 )**(i+j) * t**(k-i-j) * helper4(c, k, n, i, j)(_sage_const_1 /t)
    ans = ans.numerator().truncate((k-_sage_const_1 )//_sage_const_2  + _sage_const_1 )
    if ans[_sage_const_0 ] < _sage_const_0 :
        ans = -ans
    return ans

def helper3(c, k, n):
    ans = _sage_const_0 
    for j in range(k-c+_sage_const_1 ):
        ans = ans + binomial(n-c, j) * kazhdan_lusztig_uniform_matroid(c-_sage_const_1 , c) * (-_sage_const_1 )**(k-c-j+_sage_const_1 ) * kazhdan_lusztig_inverse_uniform(k-c-j+_sage_const_1 , n-c-j)
    for i in range(c-_sage_const_1 ):
        for j in range(k-i):
            ans = ans + binomial(c, i) * binomial(n-c, j) * (-_sage_const_1 )**(k-i-j) * helper2(c-i, k-i-j, n-i-j)
    return -ans

def helper4(c, k, n, i, j):
    ans = _sage_const_0 
    for l in range(c-i-_sage_const_1 ):
        ans = ans + (-_sage_const_1 )**l * (t-_sage_const_1 )**(max(n-i-j-l-_sage_const_1 , _sage_const_0 ))
    for u in range(n-k-_sage_const_1 ):
        ans = doit_once(ans)
    return ans

def chuly(a, b):
    ans = (t-_sage_const_1 )**b
    for i in range(b-a):
        ans = doit_once(ans)
    return ans

def doit_once(p):
    p = p // t**_sage_const_2 
    p = p * t
    p = p - p(_sage_const_1 )
    return p

def lorenzo(k, h, n):
    c = n - h
    ans1 = kazhdan_lusztig_uniform_matroid(k, n) + kazhdan_lusztig_uniform_matroid(k-c+_sage_const_1 , h) * kazhdan_lusztig_uniform_matroid(c-_sage_const_1 , c)
    ans2 = helper3(c, k, n)
    return ans1 - ans2


---------------------------------------------------------
---------------------------------------------------------
connecting crystals and schubert polynomials
---------------------------------------------------------
crystal consists of set, weight function on B to Z^(n-1), operators on set with some relation to the weight function
the set of ssyt of shape lambda filled with 1,...,n is a crystal
weight here is number of i's in the tableaux T partition 1,1,2|2,3|4 has weight (2211)
word(T) = 423112
(first examples of crystals/ will find the example later)
involution of crystals
get schur polynomials from this crystals of ssyt
some operations in B(lambda) (same example) give these schur polynomials
crystals benefit: can construct an entire family on combo objects starting from one object
demazure crystals: truncations of crystals where the operators e_i, f_i are restricted
for X subset of B(lambda), define a set D_i(X) with elements of B s.t. b in f_i^k(X) for some k>=0
for demazure crystal, B_pi(lambda) is the key polynomial K_a(x_1,...,x_n) indexed by the composition a = pi(lambda)
schubert polynomials: they represent basis for cohomology ring of some special schubert varieties
monomials of these polynomials are generated by regraphs, planar histories reduced pipe dreams and more
pipe dream: draw half of nxn grid; cover each lattice point with one of the tiles + or elbows
result is called a pipe dream
if each pipe crosses at most once, reduced pipe dream
RP(w) set of reduced pipe dreams for w
weight function = number of crosses in row i (ordered downward) of D
(knuts and miller)
sum_{D in rpw}{x^wt D} is a schubert polynomial
crystal chute moves (Bergeron-Billey)

------------------------------------------------------------------
bumpless pipe dreams generalize nicely to stuffs
------------------------------------------------------------------
------------------------------------------------------------------

..................................................................

------------------------------------------------------------------
------------------------------------------------------------------
shc - complexity of log-concave inequalities for matroids
------------------------------------------------------------------

log-concave implies unimodality
ex1: nCk as k ranges is a log-concave sequence
ex2: permutation inversion sequence aK = number of permutations in Sn with k inversions; no closed form for ak but there is a generating polynomial
ex3: ak = number of forests with k edges of graph G (proving log-concavity is extremely hard) (matroids)
-- show generalization of ex3 is strictly more difficult than the rest using complexity theory
matroids acion: hereditaty and exchange
mason's conjecture: I(k) number of independent sets with k elements. log-concavity of I(k)
^is a consequence of a stronger inequality: stanley-yan inequality
Fix S subset of X, B(k): number of bases such that B cap S has cardinality k
stanley-yan inequality: B(k) is a log-concave 
^ proved for regular matroids by stanley 81 using Alexandrov Fenchel inequality using mixed volumes
proved for all matroids by yan 23 using lorentzian polynomials
proof using stanley-yan inequality (?):
    direct sum
    for M, form M' to be direct sum of M and a free matroid F
    I(k) for M is B(k)/n! for M'

B_d(k)^2>=B_d(k-1)B_d(k+1)
form combinatorial injection from right to left
    injection A to B is combinatorial if
        given x in A, f(x) is computable in poly(|x|) steps
        given y in B it takes poly(|y|) steps to decide if y is in the image of f

ex1 has lattice paths interpretation to form combinatorial injection
    colored paths and switching colors

thm: there is no combinatorial injective proof for stanley-yan inequality (d>0) assuming NP^NP neq coNP^NP
    this assumption is slightly stronger than P neq NP
    the result is a consequence of stanley-yan inequality not being in #P
    #P = problems of counting the number of objects satisfying some property which is simple to verify
    NP =  problems asking about existence of a solution S for x where S can be verified in polynomial time
        ex: does a graph G have a proper 3-coloring? P
            count the number of proper 3-coloring. NP

    consider the computational problem
        input bin matroid M subsets S, S1, ... , Sd integers
        compute Bk^2-B.B
        both terms #P but the difference is not
    
    coNP = problem about non-existence of S but verify(S) polynomial time
    NP neq coNP implies P neq NP
    NP^NP neq coNP^NP implies NP neq coNP implies P neq NP

ex1 can be done in polynomial
ex2 can be shown that the generating function is computable in poly time

open problem: conjecture defect of masons conjecture
    I(k) log-concavity not in #P (even for graphs)

----------------------------------------------------------------
----------------------------------------------------------------